//
//  MyGeometries.cpp - Fall 2022
//
//   Sets up and renders 
//     - the ground plane, and
//     - the surface of rotation
//   for the Math 155A project #6.
//


// Use the static library (so glew32.dll is not needed):
#define GLEW_STATIC
#include <GL/glew.h> 
#include <GLFW/glfw3.h>

#include "LinearR3.h"		// Adjust path as needed.
#include "LinearR4.h"		// Adjust path as needed.
#include "MathMisc.h"       // Adjust path as needed

#include "MyGeometries.h"
#include "TextureProj.h"
#include "PhongData.h"
#include "RgbImage.h"
#include "GlGeomCylinder.h"
#include "GlGeomSphere.h"
#include "GlGeomTorus.h"
#include "ShaderMgrSLR.h"

#pragma comment(lib,"opengl32.lib")
#pragma comment(lib,"glu32.lib")
#pragma comment(lib,"glfw3.lib")
#pragma comment(lib,"glew32s.lib")
#pragma comment(lib,"glew32.lib")

bool check_for_opengl_errors();     // Function prototype (should really go in a header file)


// ********************
// Animation controls and state infornation
// ********************

// These two variables control whether running or paused.
// bool spinMode = true;
bool singleStep = false;
// bool cullBackFaces = false; // Equals true to cull backfaces. Equals false to not cull backfaces.   
bool UseRealTime = false;   // Initially use a fixed animation increment step.
double PreviousTime = 0.0;

// These three variables control the animation's state and speed.
double HourOfDay = 0.0;
double DayOfYearSun = 0.0;
double DayOfYearEarth = 0.0;
double DayOfYearMercury = 0.0;
double DayOfYearMars = 0.0;
double DayOfYearVenus = 0.0;
double DayOfYearJupiter = 0.0;
double DayOfYearSaturn = 0.0;
double DayOfYearUranus = 0.0;
double DayOfYearNeptune = 0.0;

double AnimateIncrement = 24.0;  // Time step for animation (in units of hours)


// **********************************
// Material to underlie a texture map.
// YOU MAY DEFINE A SECOND ONE OF THESE IF YOU WISH
// **********************************
phMaterial materialUnderTexture;

// **************************
// Information for loading textures
// **************************
const int NumTextures = 16;
unsigned int TextureNames[NumTextures];     // Texture names generated by OpenGL
const char* TextureFiles[NumTextures] = {
    "BrickWallTexture.bmp",         // #0
    "KalachakraSera.bmp",           // #1
    "saturn.bmp",                   // #2
    "earth_daymap.bmp",             // #3
    "BrickWallTexture.bmp",         // #4
    "mars.bmp",                     // #5
    "neptune.bmp",                  // #6
    "venus.bmp",                    // #7
    "Water.bmp",                    // #8
    "mercury.bmp",                  // #9
    "sun.bmp",                      // #10
    "moon.bmp",                     // #11
    "jupiter.bmp",                  // #12
    "saturn_ring.bmp",              // #13
    "uranus.bmp",                   // #14
    "space3.bmp",                      // #15
};


// *******************************
// For spheres and a cylinder and a torus (Torus is currently not used.)
// *******************************
GlGeomSphere texSphere(4, 4);
GlGeomCylinder texCylinder(4, 4, 4);
GlGeomTorus texTorus(4, 4, 0.2); 
GlGeomTorus torus(72, 72, 0.004);

GlGeomSphere Sun(10, 10);    // A sphere with 10 slices and 10 stacks/GlGeomSphere Sun2(10, 10); 
GlGeomSphere Planet(8, 8);    // A sphere with 10 slices and 10 stacks/GlGeomSphere Sun2(10, 10); 



// ************************
// General data helping with setting up VAO (Vertex Array Objects)
//    and Vertex Buffer Objects.
// ***********************
const int NumObjects = 8;
const int iFloor = 0;
const int iFloor2 = 3;
const int iCeil = 1;
const int iWall = 2;            // RESERVED FOR USE BY 155A PROJECT
const int iWall2 = 4;
const int iWall3 = 5;
const int iWall4 = 6;
const int iCircularSurf = 7;

unsigned int myVBO[NumObjects];  // a Vertex Buffer Object holds an array of data
unsigned int myVAO[NumObjects];  // a Vertex Array Object - holds info about an array of vertex data;
unsigned int myEBO[NumObjects];  // a Element Array Buffer Object - holds an array of elements (vertex indices)

// ********************************************
// This sets up for texture maps. It is called only once
// ********************************************
void SetupForTextures()
{
    // This material goes under the textures.
    // IF YOU WISH, YOU MAY DEFINE MORE THAN ONE OF THESE FOR DIFFERENT GEOMETRIES
    materialUnderTexture.SpecularColor.Set(0.9, 0.9, 0.9);
    materialUnderTexture.AmbientColor.Set(0.3, 0.3, 0.3);
    materialUnderTexture.DiffuseColor.Set(0.7, 0.7, 0.7);       // Increase or decrease to adjust brightness
    materialUnderTexture.SpecularExponent = 40.0;

    // ***********************************************
    // Load texture maps
	// ***********************************************
    RgbImage texMap;

    glUseProgram(shaderProgramBitmap);
    glActiveTexture(GL_TEXTURE0);
    glGenTextures(NumTextures, TextureNames);
    for (int i = 0; i < NumTextures; i++) {
        texMap.LoadBmpFile(TextureFiles[i]);            // Read i-th texture from the i-th file.
        glBindTexture(GL_TEXTURE_2D, TextureNames[i]);  // Bind (select) the i-th OpenGL texture

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

        // Set best quality filtering.   Also see below for disabling mipmaps.
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);  // Requires that mipmaps be generated (see below)
        // You may also try GL_LINEAR_MIPMAP_NEAREST -- try looking at the wall from a 30 degree angle, and look for sweeping transitions.

        // Store the texture into the OpenGL texture named TextureNames[i]
        int textureWidth = texMap.GetNumCols();
        int textureHeight = texMap.GetNumRows();
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, textureWidth, textureHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, texMap.ImageData());
 #if 1
        // Use mipmaps  (Best!)
        glGenerateMipmap(GL_TEXTURE_2D);
#else
        // Don't use mipmaps.  Try moving away from the brick wall a great distance
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
#endif

    }

    // Make sure that the shaderProgramBitmap uses the GL_TEXTURE_0 texture.
    glUseProgram(shaderProgramBitmap);
    glUniform1i(glGetUniformLocation(shaderProgramBitmap, "theTextureMap"), 0);
    glActiveTexture(GL_TEXTURE0);


}

// **********************
// This sets up geometries needed for 
//   (a) the floor (ground plane)
//   (b) the back wall
//   (c) the circular mesh
//   (d) two spheres
//   (e) one cylinder
//  It is called only once.
//  YOU NEED TO CHANGE THIS ONCE YOU ADD THE TEXTURE COORDINATES TO THE CIRCULAR SURFACE.
// **********************
void MySetupSurfaces() {

    texSphere.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    texCylinder.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    texTorus.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    Sun.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    Planet.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);
    torus.InitializeAttribLocations(vertPos_loc, vertNormal_loc, vertTexCoords_loc);

    // Initialize the VAO's, VBO's and EBO's for the ground plane, the back wall
    // and the surface of rotation. Gives them the "vertPos" location,
    // and the "vertNormal"  and the "vertTexCoords" locations in the shader program.
    // No data is loaded into the VBO's or EBO's for the circular surface until the "Remesh"
    //   routines is called

    glGenVertexArrays(NumObjects, &myVAO[0]);
    glGenBuffers(NumObjects, &myVBO[0]);
    glGenBuffers(NumObjects, &myEBO[0]);

    // For the Floor:
    // Allocate the needed Vertex Array Objects (VAO's),
    //      Vertex Buffer Objects (VBO's) and Element Array Buffer Objects (EBO's)
    // Since the floor has only four vertices.  Each vertex stores its
    //    position, its normal (0,1,0) and its (s,t)-coordinates.
    // YOU DO NOT NEED TO REMESH THE FLOOR (OR THE BACK WALL) SINCE WE USE PHONG INTERPOLATION
    float floorVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -5.0f, -5.0f, -5.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         5.0f, -5.0f, -5.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         5.0f, -5.0f,  5.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -5.0f, -5.0f,  5.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int floorElts[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iFloor]);
    glBindVertexArray(myVAO[iFloor]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(floorVerts), floorVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3*sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iFloor]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(floorElts), floorElts, GL_STATIC_DRAW);


    float floorVerts2[] = {
        // Position              // Normal                  // Texture coordinates
        -100.0f, -80.0f, -60.0f,      0.0f, 1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         100.0f, -80.0f, -60.0f,      0.0f, 1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         100.0f, -80.0f,  60.0f,      0.0f, 1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -100.0f, -80.0f,  60.0f,      0.0f, 1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int floorElts2[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iFloor2]);
    glBindVertexArray(myVAO[iFloor2]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(floorVerts2), floorVerts2, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iFloor2]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(floorElts2), floorElts2, GL_STATIC_DRAW);

    float ceilVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -100.0f, 80.0f, -60.0f,    0.0f, -1.0f, 0.0f,          0.0f, 1.0f,         // Back left
         100.0f, 80.0f, -60.0f,    0.0f, -1.0f, 0.0f,          1.0f, 1.0f,         // Back right
         100.0f, 80.0f,  60.0f,    0.0f, -1.0f, 0.0f,          1.0f, 0.0f,         // Front right
        -100.0f, 80.0f,  60.0f,    0.0f, -1.0f, 0.0f,          0.0f, 0.0f,         // Front left
    };
    unsigned int ceilElts[] = { 0, 1, 3, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iCeil]);
    glBindVertexArray(myVAO[iCeil]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(ceilVerts), ceilVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iCeil]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(ceilElts), ceilElts, GL_STATIC_DRAW);

    // For the circular surface:
    // Allocate the needed VAO, VBO < EBO
    // The normal vectors is specified separately for each vertex. (It is not a generic attribute.)
    // YOU MUST MODIFY THIS TO (A) USE STRIDES OF 8 *sizeof(float), (B) COMMENT IN THE LINES FOR vertTexCoords 

    /*
    glBindVertexArray(myVAO[iCircularSurf]);
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iCircularSurf]);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iCircularSurf]);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	// Store vertices in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float))); // Store normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);                                 // Enabled the stored normals (so they are not generic)
    // ONCE YOU HAVE TEXTURE COORDINATES WORKING FOR THE CIRCULAR SURFACE,
    //   PUT THE NEXT TWO LINES BACK IN, AND CHANGE THE STRIDE FACTOR TO "8" IN THE PREVIOUS CALLS TO glVertexAttribPointer.
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices

    // No data has been loaded into the VBO's for the circular surface yet.
    // This is done by the "SamsRemeshCircularSurf" routine.

    SamsRemeshCircularSurf();
    */

    // FOR THE BACK WALL: ADD YOUR OWN CODE!! 
    // IT WILL BE SIMILAR TO THE FLOOR ABOVE.
    // YOU DO NOT NEED TO REMESH THE BACK WALL - ONE RECTANGLE (TWO TRIANGLES) IS ENOUGH
    float wallVerts[] = {
        // Position              // Normal                  // Texture coordinates
        -100.0f, -80.0f, -60.0f,      0.0f, 0.0f, 1.0f,         0.0f, 0.0f,         // bottom left 0
         100.0f, -80.0f, -60.0f,      0.0f, 0.0f, 1.0f,         1.0f, 0.0f,         // bottom right 1
         100.0f, 80.0f, -60.0f,      0.0f, 0.0f, 1.0f,         1.0f, 1.0f,         // upper right 2
        -100.0f, 80.0f, -60.0f,      0.0f, 0.0f, 1.0f,         0.0f, 1.0f,         // upper left 3
    };
    unsigned int wallElts[] = { 0, 1, 3, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWall]);
    glBindVertexArray(myVAO[iWall]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(wallVerts), wallVerts, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWall]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(wallElts), wallElts, GL_STATIC_DRAW);


    float wallVerts2[] = {
        // Position              // Normal                  // Texture coordinates
        -100.0f, -80.0f, 60.0f,      1.0f, 0.0f, 0.0f,         0.0f, 0.0f,         // bottom left 0
        -100.0f, -80.0f, -60.0f,      1.0f, 0.0f, 0.0f,         1.0f, 0.0f,         // bottom right 1
        -100.0f, 80.0f, 60.0f,      1.0f, 0.0f, 0.0f,         1.0f, 1.0f,         // upper right 2
        -100.0f, 80.0f, -60.0f,      1.0f, 0.0f, 0.0f,         0.0f, 1.0f,         // upper left 3
    };
    unsigned int wallElts2[] = { 0, 1, 2, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWall2]);
    glBindVertexArray(myVAO[iWall2]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(wallVerts2), wallVerts2, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWall2]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(wallElts2), wallElts2, GL_STATIC_DRAW);

    float wallVerts3[] = {
        // Position              // Normal                  // Texture coordinates
        100.0f, -80.0f, 60.0f,      -1.0f, 0.0f, 0.0f,         0.0f, 0.0f,         // bottom left 0
        100.0f, -80.0f, -60.0f,      -1.0f, 0.0f, 0.0f,         1.0f, 0.0f,         // bottom right 1
        100.0f, 80.0f, 60.0f,      -1.0f, 0.0f, 0.0f,         1.0f, 1.0f,         // upper right 2
        100.0f, 80.0f, -60.0f,      -1.0f, 0.0f, 0.0f,         0.0f, 1.0f,         // upper left 3
    };
    unsigned int wallElts3[] = { 0, 2, 1, 3 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWall3]);
    glBindVertexArray(myVAO[iWall3]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(wallVerts3), wallVerts3, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWall3]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(wallElts3), wallElts3, GL_STATIC_DRAW);

    float wallVerts4[] = {
        // Position              // Normal                  // Texture coordinates
        -100.0f, -80.0f, 60.0f,      0.0f, 0.0f, -1.0f,         0.0f, 0.0f,         // bottom left 0
         100.0f, -80.0f, 60.0f,      0.0f, 0.0f, -1.0f,         1.0f, 0.0f,         // bottom right 1
         100.0f, 80.0f, 60.0f,      0.0f, 0.0f, -1.0f,         1.0f, 1.0f,         // upper right 2
        -100.0f, 80.0f, 60.0f,      0.0f, 0.0f, -1.0f,         0.0f, 1.0f,         // upper left 3
    };
    unsigned int wallElts4[] = { 0, 3, 1, 2 };
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iWall4]);
    glBindVertexArray(myVAO[iWall4]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(wallVerts4), wallVerts4, GL_STATIC_DRAW);
    glVertexAttribPointer(vertPos_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);	   // Vertex positions in the VBO
    glEnableVertexAttribArray(vertPos_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertNormal_loc, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));	// Vertex normals in the VBO
    glEnableVertexAttribArray(vertNormal_loc);									// Enable the stored vertices
    glVertexAttribPointer(vertTexCoords_loc, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));	// Vertex texture coordinates in the VBO
    glEnableVertexAttribArray(vertTexCoords_loc);									// Enable the stored vertices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iWall4]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(wallElts4), wallElts4, GL_STATIC_DRAW);

    check_for_opengl_errors();      // Watch the console window for error messages!
}

void MyRemeshGeometries() 
{
// IT IS NOT NECESSARY TO REMESH EITHER THE FLOOR OR THE BACK WALL
// YOU DO NOT NEED TO CHANGE THIS FOR PROJECT #6.

    SamsRemeshCircularSurf();
    texSphere.Remesh(meshRes, meshRes);
    texCylinder.Remesh(meshRes, meshRes, meshRes);
    texTorus.Remesh(meshRes, meshRes );
    Sun.Remesh(meshRes, meshRes);
    Planet.Remesh(meshRes, meshRes);
    check_for_opengl_errors();      // Watch the console window for error messages!
    torus.Remesh(36, 36);
}

/*
void RenderPlanet(LinearMapR4 viewMatrix, int translate, double scale, double tiltAngle, int totalHourOfDay,
    int currentHourOfDay, int totalDayOfYear, int currentDayOfYear, int material, int texture) {
    float matEntries[16];       // Temporary storage for floats
    myMaterials[material].LoadIntoShaders();
    LinearMapR4 PlanetPosMatrix = viewMatrix;
    double planetRotationAngle = (currentHourOfDay / totalHourOfDay) * PI2;
    double revolveAngle = (currentDayOfYear / totalDayOfYear) * PI2;
    PlanetPosMatrix.Mult_glRotate(revolveAngle, 0.0, 1.0, 0.0);   // Revolve the earth around the sun
    PlanetPosMatrix.Mult_glTranslate(0.0, 0.0, translate);		// Place the earth four units away from the sun
    LinearMapR4 PlanetMatrix = PlanetPosMatrix;
    PlanetMatrix.Mult_glRotate(-revolveAngle, 0.0, 1.0, 0.0);   // Rotate earth on y-axis to eliminate the affect of revolve
    PlanetMatrix.Mult_glRotate(tiltAngle, 0.0, 0.0, -1.0);
    PlanetMatrix.Mult_glRotate(planetRotationAngle, 0.0, 1.0, 0.0);   // Rotate earth on y-axis
    PlanetMatrix.Mult_glScale(scale);                          // Make radius 0.5.
    PlanetMatrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[texture]);     // Choose planet image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    Planet.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
}
*/



// **********************************************
// MODIFY THIS ROUTINE TO RENDER THE FLOOR, THE BACK WALL,
//    AND THE SPHERES AND THE CYLINDER. -- WITH TEXTURES
// **********************************************

void MyRenderGeometries() {

    float matEntries[16];       // Temporary storage for floats
    // ******
    // Render the Floor - using a procedural texture map
    // ******
    selectShaderProgram(shaderProgramProc);
    glBindVertexArray(myVAO[iFloor]);                // Select the floor VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);    
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    if (renderFloorOnly) {
        return;
    }

    // **************
    // Render the circular surface
    selectShaderProgram(shaderProgramBitmap);
   /* 
    SamsRenderCircularSurf();
    */
    
    // ************ 
    // Render the back wall
    //  YOU MUST WRITE THIS. IT WILL BE SIMILAR TO THE FLOOR ABOVE. 
    //  BUT USE A BITMAP (shaderProgramBitmap) INSTEAD OF A PROCEDURAL TEXTURE.
    // selectShaderProgram(shaderProgramProc);
    myMaterials[3].LoadIntoShaders();
    glBindVertexArray(myVAO[iWall]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);    
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[15]);     // Choose Wall image texture                                                       // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);
    // glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

    glBindVertexArray(myVAO[iWall2]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[15]);     // Choose Wall image texture                                                       // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);

    glBindVertexArray(myVAO[iWall3]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[15]);     // Choose Wall image texture                                                       // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);

    glBindVertexArray(myVAO[iWall4]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[15]);     // Choose Wall image texture                                                       // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);

    /**/
    glBindVertexArray(myVAO[iFloor2]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[15]);     // Choose Wall image texture                                                     // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);

    glBindVertexArray(myVAO[iCeil]);                // Select the wall VAO (Vertex Array Object)
    materialUnderTexture.LoadIntoShaders();         // Use the bright underlying color
    viewMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[15]);     // Choose Wall image texture                                                       // Draw the floor as a single triangle strip
    glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_INT, (void*)0);

    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    check_for_opengl_errors();

    /*
    // *************
    // Render two spheres and a cylinder
    // YOU MUST MODIFY THE CODE BELOW, AND ADD TEXTURES TO THE SPHERE AND THE CAPS OF THE CYLINDER.

    // Render a sphere with a earth image texture map
    //  YOU DO NOT NEED TO MODIFY THIS SPHERE OR ITS TEXTURE MAP
    LinearMapR4 matDemo = viewMatrix;
    matDemo.Mult_glTranslate(-3.5, 1.1, 0.4);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[3]);     // Choose Earth image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

    // Render a sphere with a texture map 
    // ADD A TEXTURE MAP TO THIS SPHERE - SIMILAR TO THE CODE ABOVE
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate( 3.5, 1.1, 0.4);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);     // Choose Mars image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texSphere.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

   
    // Render a cylinder 
    // YOU MAY LEAVE THE TEXTURE MAP ON THE SIDE OF THE CYLINDER
    // YOU MUST ADD TEXTURE MAPS TO THE TOP AND BOTTOM FACES OF THE CYLINDER
    // NOTE THERE ARE SEPARATE RENDER COMMANDS FOR THE THREE PARTS OF THE CYLINDER.
    // YOU WILL ALSO CHANGE THE ORIENTATION OF THE CYLINDER
    matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0.0, 1.1, 1.0);
    matDemo.Mult_glRotate(PIhalves, 0.0, 0.0, 1.0);
    matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[2]);     // Choose texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderSide();                             // Render the sphere side
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[7]);     // Choose Venus texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderTop();                              // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!
    glBindTexture(GL_TEXTURE_2D, TextureNames[6]);     // Choose Neptune texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    texCylinder.RenderBase();                             // RENDER THIS WITH A TEXTURE MAP
    glUniform1i(applyTextureLocation, false);             // Turn off applying texture!

    // Renders a textured torus in the back left corner.
     matDemo = viewMatrix;
     matDemo.Mult_glTranslate(-4.0, 0.3, -3.0);
     matDemo.Mult_glScale(0.8, 0.2, 0.8);
     matDemo.DumpByColumns(matEntries);           // Apply the model view matrix
     glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
     glBindTexture(GL_TEXTURE_2D, TextureNames[2]);     // Choose texture
     glUniform1i(applyTextureLocation, true);            // Enable applying the texture!
     texTorus.Render();                                  // Render the torus
     glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    */


    if (spinMode) {
        // Calculate the time step, either as AnimateIncrement or based on actual elapsed time
        double thisAnimateIncrement = AnimateIncrement;
        if (UseRealTime && !singleStep) {
            double curTime = glfwGetTime();
            thisAnimateIncrement *= (curTime - PreviousTime) * 60.0;
            PreviousTime = curTime;
        }
        // Update the animation state
        HourOfDay += thisAnimateIncrement;
        DayOfYearSun += thisAnimateIncrement / 24.0;
        DayOfYearEarth += thisAnimateIncrement / 24.0;
        DayOfYearMars += thisAnimateIncrement / 25.0;
        DayOfYearMercury += thisAnimateIncrement / 24.0;
        DayOfYearVenus += thisAnimateIncrement / 24.0;
        DayOfYearJupiter += thisAnimateIncrement / 10.0;
        DayOfYearSaturn += thisAnimateIncrement / 24.0;
        DayOfYearUranus += thisAnimateIncrement / 17.0;
        DayOfYearNeptune += thisAnimateIncrement / 24.0;

        HourOfDay = HourOfDay - ((int)(HourOfDay / 24)) * 24;       // Wrap back to be in range [0,24)
        DayOfYearSun = DayOfYearSun - ((int)(DayOfYearSun / 200)) * 200;     // Wrap back to be in range [0,200)
        DayOfYearEarth = DayOfYearEarth - ((int)(DayOfYearEarth / 365)) * 365;     // Wrap back to be in range [0,365)
        DayOfYearMars = DayOfYearMars - ((int)(DayOfYearMars / 687)) * 687;   // Wrap back to be in range [0,500)
        DayOfYearMercury = DayOfYearMercury - ((int)(DayOfYearMercury / 88)) * 88;
        DayOfYearVenus = DayOfYearVenus - ((int)(DayOfYearVenus / 225)) * 225;
        DayOfYearJupiter = DayOfYearJupiter - ((int)(DayOfYearJupiter / 4333)) * 4333;
        DayOfYearSaturn = DayOfYearSaturn - ((int)(DayOfYearSaturn / 10759)) * 10759;
        DayOfYearUranus = DayOfYearUranus - ((int)(DayOfYearUranus / 30687)) * 30687;
        DayOfYearNeptune = DayOfYearNeptune - ((int)(DayOfYearNeptune / 60190)) * 60190;

        if (singleStep) {
            spinMode = false;       // If in single step mode, turn off future animation
        }
    }
    /**/
    myMaterials[3].LoadIntoShaders();
    double sunRotationAngle = (HourOfDay / (24.0 * 1.5)) * PI2;             // Rotation angle for two suns
    double sunRevolveAngle = (DayOfYearSun / (200.0)) * PI2;             // Revolve around the center
    // SunPosMatrix - specifies position of the sun
    LinearMapR4 SunPosMatrix = viewMatrix;				                // Place Sun at center of the scene
    //SunPosMatrix.Mult_glTranslate(0.0, 0.0, -50.0);
    SunPosMatrix.Mult_glScale(7);						            // Scaling by (1, 1, 1) has no effect
    SunPosMatrix.Mult_glRotate(sunRevolveAngle, 0.0, 1.0, 0.0);         // Revolve sun on y-axis
    //SunPosMatrix.Mult_glTranslate(0.0, 0.0, 0.0);	                    // Translate 1.25 down the NEGATIVE x-axis.
    LinearMapR4 SunMatrix = SunPosMatrix;
    SunMatrix.Mult_glRotate(sunRotationAngle, 0.0, 1.0, 0.0);           // Rotate sun on y-axis
    SunMatrix.Mult_glScale(0.75);                                       // Make radius 0.75.
    
    SunMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[10]);     // Choose Mars image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    Sun.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    
    // orbit
    // Mercury
    LinearMapR4 MercuryOrbit = viewMatrix;
    MercuryOrbit.Mult_glScale(9, 0.9, 9);
    MercuryOrbit.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glVertexAttrib3f(1, 0.8f, 0.8f, 0.8f);          // Make the Torus grey
    torus.Render();
    // Venus
    LinearMapR4 VenusOrbit = viewMatrix;
    VenusOrbit.Mult_glScale(13, 0.9, 13);
    VenusOrbit.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glVertexAttrib3f(1, 0.8f, 0.8f, 0.8f);          // Make the Torus grey
    torus.Render();
    // Earth
    LinearMapR4 EarthOrbit = viewMatrix;
    EarthOrbit.Mult_glScale(16, 0.9, 16);
    EarthOrbit.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glVertexAttrib3f(1, 0.8f, 0.8f, 0.8f);          // Make the Torus grey
    torus.Render();
    // Mars
    LinearMapR4 MarsOrbit = viewMatrix;
    MarsOrbit.Mult_glScale(20, 0.9, 20);
    MarsOrbit.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glVertexAttrib3f(1, 0.8f, 0.8f, 0.8f);          // Make the Torus grey
    torus.Render();
    // saturn
    LinearMapR4 SaturnOrbit = viewMatrix;
    SaturnOrbit.Mult_glScale(41, 0.9, 41);
    SaturnOrbit.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glVertexAttrib3f(1, 0.8f, 0.8f, 0.8f);          // Make the Torus grey
    torus.Render();
    // Jupiter
    LinearMapR4 JupiterOrbit = viewMatrix;
    JupiterOrbit.Mult_glScale(30, 0.9, 30);
    JupiterOrbit.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glVertexAttrib3f(1, 0.8f, 0.8f, 0.8f);          // Make the Torus grey
    torus.Render();
    // Uranus
    LinearMapR4 UranusOrbit = viewMatrix;
    UranusOrbit.Mult_glScale(50, 0.9, 50);
    UranusOrbit.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glVertexAttrib3f(1, 0.8f, 0.8f, 0.8f);          // Make the Torus grey
    torus.Render();
    // Neptune
    LinearMapR4 NeptunerOrbit = viewMatrix;
    NeptunerOrbit.Mult_glScale(57, 0.9, 57);
    NeptunerOrbit.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glVertexAttrib3f(1, 0.8f, 0.8f, 0.8f);          // Make the Torus grey
    torus.Render();
    
    
    // EarthPosMatrix - specifies position of the earth
    // EarthMatrix - specifies the size of the earth and its rotation on its axis
    LinearMapR4 EarthPosMatrix = viewMatrix;
    double earthRotationAngle = (HourOfDay / 24.0) * PI2;
    double revolveAngle = (DayOfYearEarth / 365.0) * PI2;
    EarthPosMatrix.Mult_glRotate(revolveAngle, 0.0, 1.0, 0.0);   // Revolve the earth around the sun
    EarthPosMatrix.Mult_glTranslate(0.0, 0.0, 16);		// Place the earth four units away from the sun
    LinearMapR4 EarthMatrix = EarthPosMatrix;
    EarthMatrix.Mult_glRotate(-revolveAngle, 0.0, 1.0, 0.0);   // Rotate earth on y-axis to eliminate the affect of revolve
    EarthMatrix.Mult_glRotate(0.4, 0.0, 0.0, -1.0);
    EarthMatrix.Mult_glRotate(earthRotationAngle, 0.0, 1.0, 0.0);   // Rotate earth on y-axis
    EarthMatrix.Mult_glScale(1);                          // Make radius 0.5.
    EarthMatrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[3]);     // Choose Mars image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    Planet.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
   /* */
  /*
    RenderPlanet(viewMatrix, 4.0, 0.5, 0.4, 24, HourOfDay, 365, DayOfYearEarth, 3, 5);
  */
    // MoonMatrix - control placement, and size of the moon.
    LinearMapR4 MoonMatrix = EarthPosMatrix;        // Base the moon's matrix off the earth's *POS* matrix (EarthPosMatrix)
    double moonRotationAngle = (DayOfYearEarth * 12.0 / 365.0) * PI2;
    MoonMatrix.Mult_glRotate(-revolveAngle, 0.0, 1.0, 0.0);   // Rotate earth on z-axis
    MoonMatrix.Mult_glRotate(0.4, 0.0, 0.0, -1.0);   // Rotate earth on z-axis
    MoonMatrix.Mult_glRotate(moonRotationAngle, 0.0, 1.0, 0.0);  // Revolving around the earth twelve times per year
    MoonMatrix.Mult_glTranslate(0.0, 0.0, 2);	    // Place the Moon two unit away from the earth
    MoonMatrix.Mult_glScale(0.3);                   // Moon has radius 0.3
    MoonMatrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[11]);     // Choose Mars image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    Planet.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!


    // Mars
    LinearMapR4 MarsPosMatrix = viewMatrix;
    double marsRotationAngle = (HourOfDay / 25.0) * PI2;
    double MarsRevolveAngle = (DayOfYearMars / 687) * PI2;
    MarsPosMatrix.Mult_glRotate(MarsRevolveAngle, 0.0, 1.0, 0.0);      // Revolve the earth around the sun
    MarsPosMatrix.Mult_glTranslate(0.0, 0.0, 20);	                // Place the planet x six units away from the sun
    LinearMapR4 MarsMatrix = MarsPosMatrix;
    MarsMatrix.Mult_glRotate(-MarsRevolveAngle, 0.0, 1.0, 0.0);   // Rotate earth on y-axis to eliminate the affect of revolve
    MarsMatrix.Mult_glRotate(0.436, 0.0, 0.0, -1.0);
    MarsMatrix.Mult_glRotate(marsRotationAngle, 0.0, 1.0, 0.0);
    MarsMatrix.Mult_glScale(0.53);                                        // Make radius 0.5.
    MarsMatrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[5]);      // Choose Mars image texture
    glUniform1i(applyTextureLocation, true);            // Enable applying the texture!
    Planet.Render();                                    // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!


    // Mercury
    LinearMapR4 MercuryPosMatrix = viewMatrix;
    double MercuryRevolveAngle = (DayOfYearMercury / 88) * PI2;
    MercuryPosMatrix.Mult_glRotate(MercuryRevolveAngle, 0.0, 1.0, 0.0);      // Revolve the earth around the sun
    MercuryPosMatrix.Mult_glTranslate(0.0, 0.0, 9);	                // Place the planet x six units away from the sun
    //LinearMapR4 PlanetXMatrix = PlanetXPosMatrix;
    MercuryPosMatrix.Mult_glScale(0.38);                                        // Make radius 0.5.
    MercuryPosMatrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[9]);     // Choose Mars image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    Planet.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!


    // Jupiter
    LinearMapR4 JupiterPosMatrix = viewMatrix;
    double jupiterRotationAngle = (HourOfDay / 10.0) * PI2;
    double JupiterRevolveAngle = (DayOfYearJupiter / 4333) * PI2;
    JupiterPosMatrix.Mult_glRotate(JupiterRevolveAngle, 0.0, 1.0, 0.0);      // Revolve the earth around the sun
    JupiterPosMatrix.Mult_glTranslate(0.0, 0.0, 30);	                // Place the planet x six units away from the sun
    LinearMapR4 JupiterMatrix = JupiterPosMatrix;
    JupiterMatrix.Mult_glRotate(-JupiterRevolveAngle, 0.0, 1.0, 0.0);   // Rotate earth on y-axis to eliminate the affect of revolve
    JupiterMatrix.Mult_glRotate(0.31, 0.0, 0.0, -1.0);
    JupiterMatrix.Mult_glRotate(jupiterRotationAngle, 0.0, 1.0, 0.0);
    JupiterMatrix.Mult_glScale(4.3);                                        // Make radius 0.5.
    JupiterMatrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[12]);     // Choose Mars image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    Planet.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

    // Venus
    LinearMapR4 VenusPosMatrix = viewMatrix;
    double VenusRevolveAngle = (DayOfYearVenus / 225) * PI2;
    VenusPosMatrix.Mult_glRotate(VenusRevolveAngle, 0.0, 1.0, 0.0);      // Revolve the earth around the sun
    VenusPosMatrix.Mult_glTranslate(0.0, 0.0, 13);	                // Place the planet x six units away from the sun
    //LinearMapR4 PlanetXMatrix = PlanetXPosMatrix;
    VenusPosMatrix.Mult_glScale(0.95);                                        // Make radius 0.5.
    VenusPosMatrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[7]);     // Choose Mars image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    Planet.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

    // Saturn
    LinearMapR4 SaturnPosMatrix = viewMatrix;
    double saturnRotationAngle = (HourOfDay / 11.0) * PI2;
    double SaturnRevolveAngle = (DayOfYearSaturn / 10759) * PI2;
    SaturnPosMatrix.Mult_glRotate(SaturnRevolveAngle, 0.0, 1.0, 0.0);      // Revolve the earth around the sun
    SaturnPosMatrix.Mult_glTranslate(0.0, 0.0, 41);	                // Place the planet x six units away from the sun
    LinearMapR4 SaturnMatrix = SaturnPosMatrix;
    SaturnMatrix.Mult_glRotate(-SaturnRevolveAngle, 0.0, 1.0, 0.0);   // Rotate earth on y-axis to eliminate the affect of revolve
    SaturnMatrix.Mult_glRotate(0.47, 0.0, 0.0, -1.0);
    SaturnMatrix.Mult_glRotate(saturnRotationAngle, 0.0, 1.0, 0.0);
    SaturnMatrix.Mult_glScale(2.8);                                        // Make radius 0.5.
    SaturnMatrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[2]);     // Choose Mars image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    Planet.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
    // Saturn Ring
    LinearMapR4 ringMatrix = SaturnPosMatrix;
    double ringRotationAngle = (DayOfYearSaturn * 11.0 / 10759) * PI2;
    ringMatrix.Mult_glRotate(-SaturnRevolveAngle, 0.0, 1.0, 0.0);   // Rotate earth on y-axis to eliminate the affect of revolve
    ringMatrix.Mult_glRotate(0.47, 0.0, 0.0, -1.0);
    ringMatrix.Mult_glRotate(ringRotationAngle, 0.0, 1.0, 0.0);
    ringMatrix.Mult_glScale(4.2, 0.2, 4.2);
    ringMatrix.DumpByColumns(matEntries);           // Apply the model view matrix
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[13]);     // Choose texture
    glUniform1i(applyTextureLocation, true);            // Enable applying the texture!
    texTorus.Render();                                  // Render the torus
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!

    
    // Uranus
    LinearMapR4 UranusPosMatrix = viewMatrix;
    double UranusRevolveAngle = (DayOfYearUranus / 30687) * PI2;
    double UranusRotationAngle = (HourOfDay / 17.0) * PI2;
    UranusPosMatrix.Mult_glRotate(UranusRevolveAngle, 0.0, 1.0, 0.0);      // Revolve the earth around the sun
    UranusPosMatrix.Mult_glTranslate(0.0, 0.0, -50);	                // Place the planet x six units away from the sun
    LinearMapR4 UranusMatrix = UranusPosMatrix;
    UranusMatrix.Mult_glRotate(UranusRotationAngle, 0.0, 1.0, 0.0);
    UranusMatrix.Mult_glScale(1.8);                                        // Make radius 0.5.
    UranusMatrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[14]);     // Choose Mars image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    Planet.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!


    // Neptune
    LinearMapR4 NeptunePosMatrix = viewMatrix;
    double neptuneRotationAngle = (HourOfDay / 16.0) * PI2;
    double NeptuneRevolveAngle = (DayOfYearNeptune / 60190) * PI2;
    NeptunePosMatrix.Mult_glRotate(NeptuneRevolveAngle, 0.0, 1.0, 0.0);      // Revolve the earth around the sun
    NeptunePosMatrix.Mult_glTranslate(0.0, 0.0, 57);	                // Place the planet x six units away from the sun
    LinearMapR4 NeptuneMatrix = NeptunePosMatrix;
    NeptuneMatrix.Mult_glRotate(-NeptuneRevolveAngle, 0.0, 1.0, 0.0);   // Rotate earth on y-axis to eliminate the affect of revolve
    NeptuneMatrix.Mult_glRotate(0.49, 0.0, 0.0, -1.0);
    NeptuneMatrix.Mult_glRotate(neptuneRotationAngle, 0.0, 1.0, 0.0);
    NeptuneMatrix.Mult_glScale(1.6);                                        // Make radius 0.5.
    NeptuneMatrix.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries);
    glBindTexture(GL_TEXTURE_2D, TextureNames[6]);     // Choose Mars image texture
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
    Planet.Render();                                 // Render the sphere
    glUniform1i(applyTextureLocation, false);           // Turn off applying texture!
/**/





        
    check_for_opengl_errors();      // Watch the console window for error messages!
}

void SamsRenderCircularSurf()
{
    float matEntries[16];       // Temporary storage for floats

    glBindVertexArray(myVAO[iCircularSurf]);

    // Calculate the model view matrix for the circular surface
    LinearMapR4 matDemo = viewMatrix;
    matDemo.Mult_glTranslate(0.0, 0.8, -2.5);     // Center in the back & raise up
    matDemo.Mult_glScale(0.18, 0.4, 0.18);         // Adjust the circular diameter and height

                                                 // Set the uniform values (they are not stored with the VAO and thus must be set again everytime
    materialUnderTexture.LoadIntoShaders();                       // Use the bright underlying material
    matDemo.DumpByColumns(matEntries);
    glUniformMatrix4fv(modelviewMatLocation, 1, false, matEntries); // Select the modelview matrix to place it
    glBindTexture(GL_TEXTURE_2D, TextureNames[8]);     // Choose Water texture
    // ONCE YOU HAVE TEXTURE COORDINATES FOR THE CIRCULAR SURFACE, PUT THE NEXT LINE BACK IN.
    glUniform1i(applyTextureLocation, true);           // Enable applying the texture!
                                                                   // Draw the the triangle strips
    for (int i = 0; i < meshRes; i++) {
        glDrawElements(GL_TRIANGLE_STRIP, 1 + 2 * meshRes, GL_UNSIGNED_INT,
            (void*)(i * (1 + 2 * meshRes) * sizeof(unsigned int)));
    }
    glUniform1i(applyTextureLocation, false);           // Disable applying the texture!
}


// *******
// ADD TEXTURE COORDINATES TO EITHER YOUR OWN "MyRemeshCircularSurf" or
// TO THE PROVIDED "SamsRemeshCircularSurf"
// IF YOU USE YOUR OWN, ALSO REPLACE "SamsRenderCircularMesh" WITH YOUR
// OWN "MyRenderCircularMesh" IF NEEDED.
// TASKS FOR ADDING TEXTURE COORDINATES:
//    a. Change stride to 8*sizeof(float) instead 6*sizeof(float).
//    b. Be sure to allocate enough memory for circularVerts[].
//    c. Calculate the (s,t) texture coordinates, put them in the array.
//    d. Update the calls to glVertexAttribPointer and glEnableVertexAttribArray
//         in the routine MySetupSurfaces above.  
//       And, add new calls for the texture coordinates.

void SamsRemeshCircularSurf()
{
    // Circular surface vertices.
    int numCircularVerts = 1 + meshRes * meshRes;
    float* circularVerts = new float[8 * numCircularVerts];
    // Circular surface elements (indices to vertices in a triangle strip)
    int numCircularElts = meshRes * (1 + 2 * meshRes);
    unsigned int* circularElements = new unsigned int[numCircularElts];

    float* toPtr = circularVerts;
    *(toPtr++) = 0.0f;      // Center point
    *(toPtr++) = 1.0f;
    *(toPtr++) = 0.0f;
    *(toPtr++) = 0.0f;      // Center normal
    *(toPtr++) = 1.0f;
    *(toPtr++) = 0.0f;
    *(toPtr++) = 0.5f;      // Center coordinates
    *(toPtr++) = 0.5f;
    for (int i = 0; i < meshRes; i++) {
        float theta = (float)PI2 * ((float)i) / (float)meshRes;
        float c = cosf(theta);
        float s = sinf(theta);
        float partialC = -s;
        float partialS = c;

        VectorR3 partialTheta(partialC, 0.0, partialS);
        for (int j = 1; j <= meshRes; j++) {
            float r = 2.9f * (float)PI * ((float)j) / (float)meshRes;
            float x = r;
            float dampingFactor = 0.08f;
            float fff = (float)(1.0 + dampingFactor * r * r);
            float y = j==0 ? 1.0f : fff*sin(r)/r;
            float xprime = 1.0;
            float yprime = (x * cosf(x) + sinf(x)) / (x + 1.0f) - x * sinf(x) / ((x + 1.0f) * (x + 1.0f));
            VectorR3 partialR((double)(c * xprime), yprime, (double)(s * xprime));
            *(toPtr++) = c * x;                 // (i,j) point
            *(toPtr++) = y;
            *(toPtr++) = s * x;
            VectorR3 normal = -partialR * partialTheta;
            normal.Normalize();
            *(toPtr++) = (float)normal.x;      // (i,j) normal
            *(toPtr++) = (float)normal.y;
            *(toPtr++) = (float)normal.z;
            // vertex coordinates
            *(toPtr++) = (float) 0.5 + 0.5 * c * x / (1.62 * 2.9f * (float)PI + 1);
            *(toPtr++) = (float) 0.5 + 0.5 * s * x / (1.62 * 2.9f * (float)PI + 1);
       }
    }

    unsigned int* toElt = circularElements;
    for (int i = 0; i < meshRes; i++) {
        *(toElt++) = 0;         // Central vertex
        for (int j = 0; j < meshRes; j++) {
            *(toElt++) = ((i + 1) % meshRes) * meshRes + j + 1;
            *(toElt++) = i * meshRes + j + 1;
        }
    }

    glBindVertexArray(myVAO[iCircularSurf]);
    glBindBuffer(GL_ARRAY_BUFFER, myVBO[iCircularSurf]);
    glBufferData(GL_ARRAY_BUFFER, 8 * numCircularVerts * sizeof(float), circularVerts, GL_STATIC_DRAW);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, myEBO[iCircularSurf]);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, numCircularElts * sizeof(unsigned int), circularElements, GL_STATIC_DRAW);

    delete[] circularVerts;
    delete[] circularElements;
}
